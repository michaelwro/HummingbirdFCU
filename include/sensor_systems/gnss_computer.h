


/**
 * Teensy 4.1 has a 64 byte serial buffer that can be expanded with:
 *      Serial1.addMemoryForRead(void *buffer, size_t size)
 */



#pragma once



#include <Arduino.h>
#include "hummingbird_config.h"
#include "maths/vectors.h"
#include "TinyGPS++.h"
#include "constants.h"


#if defined(DEBUG) && defined(DEBUG_PORT)
    /* Print GNSS debug messages to the debug serial port */
    #define GNSS_DEBUG
#endif


/** 
 * [ms] millis() How long we will wait for the GPS to get a position lock and connect to at 
 * least N sats. 
 */
constexpr uint32_t GNSS_POS_LOCK_TIMEOUT = 120000;

/* Baud rate that the unconfigured GPS has when powered up */
constexpr int32_t GNSS_DEFAULT_BAUD = 9600;

/* BAUD RATE CONFIGURATION */
/* Possible baud rates for the GNSS sensor */
typedef enum
{
    GNSS_BAUD_9600,     // 9600 serial baud rate (default when NEO-M8N powers up)
    GNSS_BAUD_38400,    // 38.4k serial baud rate
    GNSS_BAUD_115200,   // 115.2K serial baud rate
    GNSS_BAUD_230400    // 230.4k serial baud rate
} GNSSBaudRates_t;

constexpr char UBX_CFG_PRT_9600B[28] = {
    0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x80,
    0x25,0x00,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x9B,0x7F
}; // UBX CFG message to set UART1 baud to 9600, UBX In, NMEA out

constexpr char UBX_CFG_PRT_38400B[28] = {
    0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,
    0x96,0x00,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x8C,0x5A
};  // UBX CFG message to set UART1 baud to 38400, UBX In, NMEA out

constexpr char UBX_CFG_PRT_115200B[28] = {
    0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,
    0xC2,0x01,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0xB9,0x48
};  // UBX CFG message to set UART1 baud to 115200, UBX In, NMEA out

constexpr char UBX_CFG_PRT_230400B[28] = {
    0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,
    0x84,0x03,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x7D,0xB2
};  // UBX CFG message to set UART1 baud to 230400, UBX In, NMEA out 




/* Possible GNSS networks to connect to. */
typedef enum
{
    GNSS_NET_GPS,           // Connect to GPS network, max. 10Hz on NEO-M8N
    GNSS_NET_GLONASS,       // Connect to GLONASS network, max. 10Hz on NEO-M8N
    GNSS_NET_GPS_GLONASS    // Connect to both GPS and GLONASS, max. 5Hz on NEO-M8N
} GNSSNetworks_t;


constexpr char UBX_CFG_GNSS_GPS[68] = {
    0xB5,0x62,0x06,0x3E,0x3C,0x00,0x00,0x00,0x20,0x07,0x00,0x08,0x10,0x00,0x01,
    0x00,0x01,0x01,0x01,0x01,0x03,0x00,0x01,0x00,0x01,0x01,0x02,0x04,0x08,0x00,
    0x00,0x00,0x01,0x01,0x03,0x08,0x10,0x00,0x00,0x00,0x01,0x01,0x04,0x00,0x08,
    0x00,0x00,0x00,0x01,0x01,0x05,0x00,0x03,0x00,0x01,0x00,0x01,0x01,0x06,0x08,
    0x0E,0x00,0x00,0x00,0x01,0x01,0x2E,0x85
};  // UBX CFG message to configure and enable GPS, SBAS, and QZSS

constexpr char UBX_CFG_GNSS_GLONASS[68] = {
    0xB5,0x62,0x06,0x3E,0x3C,0x00,0x00,0x00,0x20,0x07,0x00,0x08,0x10,0x00,0x00,
    0x00,0x01,0x01,0x01,0x01,0x03,0x00,0x01,0x00,0x01,0x01,0x02,0x04,0x08,0x00,
    0x00,0x00,0x01,0x01,0x03,0x08,0x10,0x00,0x00,0x00,0x01,0x01,0x04,0x00,0x08,
    0x00,0x00,0x00,0x01,0x01,0x05,0x00,0x03,0x00,0x01,0x00,0x01,0x01,0x06,0x08,
    0x0E,0x00,0x01,0x00,0x01,0x01,0x2E,0x55
};  // UBX CFG message to configure and enable GLONASS, SBAS, and QZSS

constexpr char UBX_CFG_GNSS_GPS_GLONASS[68] = {
    0xB5,0x62,0x06,0x3E,0x3C,0x00,0x00,0x00,0x20,0x07,0x00,0x08,0x10,0x00,0x01,
    0x00,0x01,0x01,0x01,0x01,0x03,0x00,0x01,0x00,0x01,0x01,0x02,0x04,0x08,0x00,
    0x00,0x00,0x01,0x01,0x03,0x08,0x10,0x00,0x00,0x00,0x01,0x01,0x04,0x00,0x08,
    0x00,0x00,0x00,0x01,0x01,0x05,0x00,0x03,0x00,0x01,0x00,0x01,0x01,0x06,0x08,
    0x0E,0x00,0x01,0x00,0x01,0x01,0x2F,0x89
};  // UBX CFG message to configure and enable GPS, SBAS, QZSS, and GLONASS


/* Various dynamic models for the GPS receiver's sensor fusion algorithms */
typedef enum
{
    GNSS_DYNAMICS_PORTABLE,     // Portable dynamic model, 12000m alt, 310m/s hvel, 50m/s vvel, med. dev.
    GNSS_DYNAMICS_PEDESTRIAN,   // Pedestrian dynamic model, 9000m alt, 30m/s hvel, 20m/s vvel, small dev.
    GNSS_DYNAMICS_AIRBORNE_1G    // Airborne 1G dynamic model, 50000m alt, 100m/s hvel, 100m/s vvel, large dev.
} GNSSDynamics_t;


/* GPS fix status codes */
typedef enum
{
    // GNSS_FIX_NO_GPS,    // No GPS sensor connected/detected
    GNSS_FIX_NONE,      // Receiving valid GPS data, but with no position lock
    GNSS_FIX_2D,        // Receiving valid GPS data with a 2D lock
    GNSS_FIX_3D         // Receiving valid GPS data with a 3D lock
} GNSSFix_t;

constexpr char UBX_CFG_NAV5_PORTABLE_3D[44] = {
    0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x00,0x02,0x00,0x00,0x00,0x00,0x10,
    0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7D,0x1B
};  // UBX CFG message to set portable dynamic model and 3D fix only

constexpr char UBX_CFG_NAV5_PEDESTRIAN_3D[44] = {
    0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x03,0x02,0x00,0x00,0x00,0x00,0x10,
    0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x81
};  // UBX CFG message to set pedestrian dynamic model and 3D fix only

constexpr char UBX_CFG_NAV5_AIR1G_3D[44] = {
    0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x06,0x02,0x00,0x00,0x00,0x00,0x10,
    0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0xE7
};  // UBX CFG message to set Airborne <1G dynamic model and 3D fix only



/* GPS inavigation rates */
typedef enum
{
    GNSS_NAVRATE_5HZ = 5,   // 5 Hz navigation rate/output rate
    GNSS_NAVRATE_10HZ = 10  // 10 Hz navigation rate/output rate
} GNSSNavRate_t;

/* GPS configuration error types */
typedef enum
{
    GNSS_CONFIG_SUCCESS,  // Successful configuration
    GNSS_CONFIG_NO_DEVICE,  // No GPS sensor connected/detected
    GNSS_CONFIG_RECONNECT_ERROR,  // When we change the baud rate and cannot reconnect to the GPS
    GNSS_CONFIG_NO_HOME_LOCATION  // No home location specified
} GNSSConfig_t;


/* UBX Configuration char Arrays */
constexpr char UBX_CFG_RATE_5HZ[14] = {
    0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A
};  // UBX CFG message to set nav. rate to 5Hz GPS time

constexpr char UBX_CFG_RATE_10HZ[14] = {
    0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12
};  // UBX CFG message to set nav. rate to 10Hz GPS time


class GNSSComputer
{
public:
    GNSSComputer(HardwareSerial *userSerial = &GPS_PORT);
    bool ConfigureDevice(
        GNSSBaudRates_t userBaud    = GNSS_BAUD_115200, 
        GNSSNetworks_t userNetwork  = GNSS_NET_GPS_GLONASS, 
        GNSSDynamics_t userDynModel = GNSS_DYNAMICS_PEDESTRIAN,
        GNSSNavRate_t userODR       = GNSS_NAVRATE_5HZ
        );
    bool Initialize();
protected:
private:
    TinyGPSPlus gpsDevice;          // TinyGPS++ GPS object
    Vectord PosLLA;     // [rad, rad, m] Lat, lon, altitude
    Vectorf PosECEF;    // [m, m, m] ECEF position
    Vectorf VelECEF;    // [m/s, m/s, m/s] ECEF velocity
    void SendUBXConfigMessage(const char *msg, size_t len);
    // LPF for smoothing gps pos (to smooth out impulses/sharp changes)
    // LPF for smoothing altitude
private:
    bool isConfigured;  // True if ConfigureDevice() was called, false if not
    int32_t gpsBaud;  // Baud rate for serial connection
    float navTs;  // [sec] GPS navigation sample period
    float navRate;  // [Hz] GPS navigation rate
    

    // GNSSBaudRates_t gpsBaud;        // Baud rate for GPS serial communication
    GNSSNetworks_t network;         // Satellite network(s) that the GPS is connected to
    GNSSDynamics_t dynamicModel;    // Dynamic model for the GPS fusion algorithms
    GNSSNavRate_t updateRate;       // [Hz] navigation rate from gps
    HardwareSerial *gpsSerial;      // HW serial port that the GPS is connected to
};